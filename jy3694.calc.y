%{
#define _USE_MATH_DEFINES
#include <cmath>
#include <iostream>
#include <math.h>
#include <stdio.h>

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };
double factorial(double n){return (n==0) || (n==1) ? 1 : n* factorial(n-1);}
double mod(double n1, double n2){ return int(n1) % int(n2);}
double usd_to_gbp(double amount, bool reverse=false) 
{
  double out, rate=0.80; //conversion rate of usd to gbp on June 5, 2022
  if (reverse) out = (1/rate) * amount; else out = amount * rate;
  return out;
}
double gbp_to_euro(double amount, bool reverse=false) 
{
  double out, rate=1.16; //conversion rate of usd to gbp on June 5, 2022
  if (reverse) out = (1/rate) * amount; else out = amount * rate;
  return out;
}
double usd_to_euro(double amount, bool reverse=false) 
{
  double out, rate=0.93; //conversion rate of usd to gbp on June 5, 2022
  if (reverse) out = (1/rate) * amount; else out = amount * rate;
  return out;
}
%}

%union {
    double val;
    /* You may include additional fields as you want. */
    /* char op; */
};

%start program_input

%token EOL PI NUMBER SUB ADD MUL DIV POW MOD L_BRACKET R_BRACKET FACTORIAL
%token SQRT ABS FLOOR CEIL COS SIN TAN LOG2 LOG10 
%token GBP_TO_USD USD_TO_GBP GBP_TO_EURO EURO_TO_GBP USD_TO_EURO EURO_TO_USD
%token CEL_TO_FAH FAH_TO_CEL
%token MI_TO_KM KM_TO_MI
%token VAR_KEYWORD VARIABLE EQUALS
%token <val> NUMBER    /* 'val' is the (only) field declared in %union
%token <char>                        which represents the type of the token. */

%type <val> program_input line calculation expr function constant temp_conversion conversion dist_conversion log_function trig_function

%%
program_input : line { $$ = $1;}
							;

line : EOL 
		 | calculation EOL 
		 ;

calculation : expr
						;

constant : PI 		{$$ = M_PI; }
				 ;

expr : SUB expr		{$$ = - $2;}
		 | NUMBER		
		 | VARIABLE
		 | constant
		 | function
		 | expr DIV expr		{ $$ = $1 / $3;}
		 | expr MUL expr		{ $$ = $1 * $3;}
		 | expr ADD expr		{ $$ = $1 + $3;}
		 | expr POW expr		{ $$ = pow($1, $3);}
		 | expr MOD expr		{ $$ = mod($1, $3);}
		 | L_BRACKET expr R_BRACKET { $$ = $2; }
		 ;

function : conversion
				 | log_function
				 | trig_function
				 | expr FACTORIAL { $$ = factorial($1); }
				 | SQRT expr			{ $$ = sqrt($2); }
				 | ABS expr				{ $$ = $2 >= 0? $2 : - $2; }
				 | FLOOR expr			{ $$ = floor($2); }
				 | CEIL expr 			{ $$ = ceil($2); }
				 ;

trig_function : COS expr	{ $$ = cos($2); }
							| SIN expr	{ $$ = sin($2); }
							| TAN expr  { $$ = tan($2); }
							;

log_function : LOG2 expr  { $$ = log2($2); }
						 | LOG10 expr { $$ = log10($2); }
						 ;

conversion : temp_conversion
					 | dist_conversion
					 | expr GBP_TO_USD { $$ = usd_to_gbp($1, true); }
					 | expr USD_TO_GBP { $$ = usd_to_gbp($1); }
					 | expr GBP_TO_EURO { $$ = gbp_to_euro($1); }
					 | expr EURO_TO_GBP { $$ = gbp_to_euro($1, true); }
					 | expr USD_TO_EURO { $$ = usd_to_euro($1); }
					 | expr EURO_TO_USD { $$ = usd_to_euro($1, true); }
					 ;

temp_conversion : expr CEL_TO_FAH		{ $$ = $1; }
								| expr FAH_TO_CEL		{ $$ = $1; }
								;

dist_conversion : expr MI_TO_KM			{ $$ = $1; }
								| expr KM_TO_MI			{ $$ = $1; }
								;
/*
assignment : VAR_KEYWORD VARIABLE EQUALS calculation*/








%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}

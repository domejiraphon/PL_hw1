%{
#include <iostream>
#include <math.h>
#include <stdio.h>

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "ERROR: Undefined symbol" << p << std::endl; };
double factorial(double n){return (n==0) || (n==1) ? 1 : n* factorial(n-1);}
double mod(double n1, double n2){ return int(n1) % int(n2);}
double usd_to_gbp(double amount, bool reverse=false) 
{
  double out, rate=0.80; //conversion rate of usd to gbp on June 5, 2022
  if (reverse) out = (1/rate) * amount; else out = amount * rate;
  return out;
}
double gbp_to_euro(double amount, bool reverse=false) 
{
  double out, rate=1.16; //conversion rate of usd to gbp on June 5, 2022
  if (reverse) out = (1/rate) * amount; else out = amount * rate;
  return out;
}
double usd_to_euro(double amount, bool reverse=false) 
{
  double out, rate=0.93; //conversion rate of usd to gbp on June 5, 2022
  if (reverse) out = (1/rate) * amount; else out = amount * rate;
  return out;
}
double mi_to_km(double dist, bool reverse=false) 
{
  double out, rate=1.609344; //conversion rate for 1 mile to km 
  if (reverse) out = (1/rate) * dist; else out = dist * rate;
  return out;
}
%}

%union {
    double val;
    /* You may include additional fields as you want. */
    /* char op; */
};

%start program_input
%token EOL PI ADD SUB MUL DIV FACTORIAL POW MOD
%token SQRT ABS FLOOR CEIL COS SIN TAN LOG2 LOG10 
%token L_BRACKET R_BRACKET 
%token GBP_TO_USD USD_TO_GBP GBP_TO_EURO EURO_TO_GBP USD_TO_EURO EURO_TO_USD
%token CEL_TO_FAH FAH_TO_CEL
%token MI_TO_KM KM_TO_MI
%token VAR_KEYWORD VARIABLE EQUALS
%token <val> NUMBER    /* 'val' is the (only) field declared in %union
%token <char>                        which represents the type of the token. */
%type <val> expr function log_function trig_function conversion program_input 
%type <val> temp_conversion dist_conversion constant low_priority_expr

%%
program_input : line	
							| program_input line 
							;
              
line : EOL 
		 | calculation EOL 
		 ;

calculation : low_priority_expr        { std::cout << $1 << std::endl; }
						;

constant : PI 		{$$ = M_PI; }
				 ;

low_priority_expr : low_priority_expr ADD expr		{ $$ = $1 + $3;}
                  | low_priority_expr SUB expr		{ $$ = $1 - $3;}
                  | expr
                  ;

expr : SUB expr		{$$ = -1 * $2;}
     | function
     | constant
     | NUMBER
		 | expr DIV expr		{ $$ = $1 / $3;}
		 | expr MUL expr		{ $$ = $1 * $3;}
		 | expr POW expr		{ $$ = pow($1, $3);}
		 | expr MOD expr		{ $$ = mod($1, $3);}
		 | L_BRACKET expr R_BRACKET { $$ = $2; }
		 ;

function : conversion
         | log_function
         | trig_function
				 | expr FACTORIAL { $$ = factorial($1); }
				 | SQRT expr			{ $$ = sqrt($2); }
				 | ABS expr				{ $$ = $2 >= 0? $2 : - $2; }
				 | FLOOR expr			{ $$ = floor($2); }
				 | CEIL expr 			{ $$ = ceil($2); }
				 ;

trig_function : COS expr	{ $$ = cos($2); }
							| SIN expr	{ $$ = sin($2); }
							| TAN expr  { $$ = tan($2); }
							;

log_function : LOG2 expr  { $$ = log2($2); }
						 | LOG10 expr { $$ = log10($2); }
						 ;

conversion : temp_conversion
					 | dist_conversion
					 | expr GBP_TO_USD { $$ = usd_to_gbp($1, true); }
					 | expr USD_TO_GBP { $$ = usd_to_gbp($1); }
					 | expr GBP_TO_EURO { $$ = gbp_to_euro($1); }
					 | expr EURO_TO_GBP { $$ = gbp_to_euro($1, true); }
					 | expr USD_TO_EURO { $$ = usd_to_euro($1); }
					 | expr EURO_TO_USD { $$ = usd_to_euro($1, true); }
					 ;

temp_conversion : expr CEL_TO_FAH		{ $$ = $1; }
								| expr FAH_TO_CEL		{ $$ = $1; }
								;

dist_conversion : expr MI_TO_KM			{ $$ = mi_to_km($1); }
								| expr KM_TO_MI			{ $$ = mi_to_km($1, true); }
								;

%%

int main()
{ while (true){
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
  }
}

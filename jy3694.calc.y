%{
#define _USE_MATH_DEFINES
#include <cmath>
#include <iostream>
#include <math.h>
#include <stdio.h>

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };
double factorial(int n){return (n==0) || (n==1) ? 1 : n* factorial(n-1);}

%}

%union {
    double val;
    /* You may include additional fields as you want. */
    /* char op; */
};

%start program_input

%token LPAREN RPAREN
%token PLUS MINUS MUL DIV SIN
%token <val> NUM    /* 'val' is the (only) field declared in %union
%token <char>                        which represents the type of the token. */


%%
program_input : \*epsilon*\
							| program_input line { $$ = $1;}
							;

line : EOL 
		 | calculation EOL 
		 ;

calculation : expr
						| assignment
						;

constant : PI 		{$$ = M_PI; }
				 ;

expr : SUB expr		{$$ = -$1 * $2;}
		 | NUMBER		
		 | VARIABLE
		 | constant
		 | function
		 | expr DIV expr		{ $$ = $1 / $3;}
		 | expr MUL expr		{ $$ = $1 * $3;}
		 | expr ADD expr		{ $$ = $1 + $3;}
		 | expr POW expr		{ $$ = pow($1, $3);}
		 | expr MOD expr		{ $$ = $1 % $3;}
		 ;

function : conversion
				 | log_function
				 | trig_function
				 | expr FACTORIAL { $$ = factorial($2); }
				 | SQRT expr			{ $$ = sqrt($1); }
				 | ABS expr				{ $$ = $2 >= 0? $2 : - $2; }
				 | FLOOR expr			{ $$ = floor($2); }
				 | CEIL expr 			{ $$ = ceil($2); }
				 ;

trig_function : COS expr	{ $$ = cos($2); }
							| SIN expr	{ $$ = sin($2); }
							| TAN expr  { $$ = tan($2); }
							;

log_function : LOG2 expr  { $$ = log2($2); }
						 | LOG10 expr { $$ = log10($2); }
						 ;

conversion : temp_conversion
					 | dist_conversion
					 | expr GBP_TO_USD { $$ = 1.2 * $2; }
					 | expr USD_TO_GBP { $$ = 1/1.2 * $2; }
					 | expr GBP_TO_EURO { $$ = 1.2 * $2; }
					 | expr EURO_TO_GBP { $$ = 1.2 * $2; }
					 | expr USD_TO_EURO { $$ = 1/1.2 * $2; }
					 | expr EURO_TO_USD { $$ = 1.2 * $2; }
					 ;

temp_conversion : expr CEL_TO_FAH		{ $$ = $1; }
								| expr FAH_TO_CEL		{ $$ = $1; }
								;

dist_conversion : expr MI_TO_KM			{ $$ = $1; }
								| expr KM_TO_MI			{ $$ = $1; }
								;

assignment : VAR_KEYWORD VARIABLE EQUALS calculation








%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}
